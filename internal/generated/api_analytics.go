/*
LeapOCR API

Provide your JWT token via the `Authorization` header. Example: Authorization: Bearer <token>

API version: v1
Contact: support@leapocr.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type AnalyticsAPI interface {

	/*
		AnalyticsCreditsUsageGet Get credit usage analytics

		Returns comprehensive credit analytics including snapshot data, timeseries trends, and model usage breakdown

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AnalyticsAPIAnalyticsCreditsUsageGetRequest
	*/
	AnalyticsCreditsUsageGet(ctx context.Context) AnalyticsAPIAnalyticsCreditsUsageGetRequest

	// AnalyticsCreditsUsageGetExecute executes the request
	//  @return AnalyticsCreditsUsageResponse
	AnalyticsCreditsUsageGetExecute(r AnalyticsAPIAnalyticsCreditsUsageGetRequest) (*AnalyticsCreditsUsageResponse, *http.Response, error)

	/*
		AnalyticsJobsTimeseriesGet Get job analytics timeseries

		Returns job metrics aggregated by time buckets including total jobs, completed jobs, failed jobs, active jobs, pages processed, and credits consumed

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AnalyticsAPIAnalyticsJobsTimeseriesGetRequest
	*/
	AnalyticsJobsTimeseriesGet(ctx context.Context) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest

	// AnalyticsJobsTimeseriesGetExecute executes the request
	//  @return AnalyticsJobsTimeseriesGet200Response
	AnalyticsJobsTimeseriesGetExecute(r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) (*AnalyticsJobsTimeseriesGet200Response, *http.Response, error)

	/*
		AnalyticsOverviewGet Get analytics overview

		Returns high-level analytics insights including job statistics, page outcomes, credit usage, and webhook metrics for the specified time range

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AnalyticsAPIAnalyticsOverviewGetRequest
	*/
	AnalyticsOverviewGet(ctx context.Context) AnalyticsAPIAnalyticsOverviewGetRequest

	// AnalyticsOverviewGetExecute executes the request
	//  @return AnalyticsOverviewResponse
	AnalyticsOverviewGetExecute(r AnalyticsAPIAnalyticsOverviewGetRequest) (*AnalyticsOverviewResponse, *http.Response, error)

	/*
		AnalyticsPagesTimeseriesGet Get page analytics timeseries

		Returns page outcomes aggregated by time buckets including totals, completion, failure, and token counts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AnalyticsAPIAnalyticsPagesTimeseriesGetRequest
	*/
	AnalyticsPagesTimeseriesGet(ctx context.Context) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest

	// AnalyticsPagesTimeseriesGetExecute executes the request
	//  @return AnalyticsPagesTimeseriesGet200Response
	AnalyticsPagesTimeseriesGetExecute(r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) (*AnalyticsPagesTimeseriesGet200Response, *http.Response, error)

	/*
		AnalyticsTemplatesTopGet Get top templates analytics

		Returns the most frequently used templates ranked by job count, usage count, and credits consumed

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AnalyticsAPIAnalyticsTemplatesTopGetRequest
	*/
	AnalyticsTemplatesTopGet(ctx context.Context) AnalyticsAPIAnalyticsTemplatesTopGetRequest

	// AnalyticsTemplatesTopGetExecute executes the request
	//  @return AnalyticsTopTemplatesResponse
	AnalyticsTemplatesTopGetExecute(r AnalyticsAPIAnalyticsTemplatesTopGetRequest) (*AnalyticsTopTemplatesResponse, *http.Response, error)
}

// AnalyticsAPIService AnalyticsAPI service
type AnalyticsAPIService service

type AnalyticsAPIAnalyticsCreditsUsageGetRequest struct {
	ctx         context.Context
	ApiService  AnalyticsAPI
	range_      *string
	start       *string
	end         *string
	bucket      *string
	granularity *string
	teamId      *string
}

// Time range preset
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) Range_(range_ string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.range_ = &range_
	return r
}

// Start date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) Start(start string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.start = &start
	return r
}

// End date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) End(end string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.end = &end
	return r
}

// Time bucket granularity
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) Bucket(bucket string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.bucket = &bucket
	return r
}

// Alias for bucket parameter
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) Granularity(granularity string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.granularity = &granularity
	return r
}

// Filter by team ID
func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) TeamId(teamId string) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	r.teamId = &teamId
	return r
}

func (r AnalyticsAPIAnalyticsCreditsUsageGetRequest) Execute() (*AnalyticsCreditsUsageResponse, *http.Response, error) {
	return r.ApiService.AnalyticsCreditsUsageGetExecute(r)
}

/*
AnalyticsCreditsUsageGet Get credit usage analytics

Returns comprehensive credit analytics including snapshot data, timeseries trends, and model usage breakdown

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AnalyticsAPIAnalyticsCreditsUsageGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsCreditsUsageGet(ctx context.Context) AnalyticsAPIAnalyticsCreditsUsageGetRequest {
	return AnalyticsAPIAnalyticsCreditsUsageGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnalyticsCreditsUsageResponse
func (a *AnalyticsAPIService) AnalyticsCreditsUsageGetExecute(r AnalyticsAPIAnalyticsCreditsUsageGetRequest) (*AnalyticsCreditsUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsCreditsUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsCreditsUsageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/credits/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.bucket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket", r.bucket, "form", "")
	}
	if r.granularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "form", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_id", r.teamId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AnalyticsAPIAnalyticsJobsTimeseriesGetRequest struct {
	ctx         context.Context
	ApiService  AnalyticsAPI
	range_      *string
	start       *string
	end         *string
	bucket      *string
	granularity *string
	teamId      *string
}

// Time range preset
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) Range_(range_ string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.range_ = &range_
	return r
}

// Start date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) Start(start string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.start = &start
	return r
}

// End date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) End(end string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.end = &end
	return r
}

// Time bucket granularity
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) Bucket(bucket string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.bucket = &bucket
	return r
}

// Alias for bucket parameter
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) Granularity(granularity string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.granularity = &granularity
	return r
}

// Filter by team ID
func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) TeamId(teamId string) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	r.teamId = &teamId
	return r
}

func (r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) Execute() (*AnalyticsJobsTimeseriesGet200Response, *http.Response, error) {
	return r.ApiService.AnalyticsJobsTimeseriesGetExecute(r)
}

/*
AnalyticsJobsTimeseriesGet Get job analytics timeseries

Returns job metrics aggregated by time buckets including total jobs, completed jobs, failed jobs, active jobs, pages processed, and credits consumed

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AnalyticsAPIAnalyticsJobsTimeseriesGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsJobsTimeseriesGet(ctx context.Context) AnalyticsAPIAnalyticsJobsTimeseriesGetRequest {
	return AnalyticsAPIAnalyticsJobsTimeseriesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnalyticsJobsTimeseriesGet200Response
func (a *AnalyticsAPIService) AnalyticsJobsTimeseriesGetExecute(r AnalyticsAPIAnalyticsJobsTimeseriesGetRequest) (*AnalyticsJobsTimeseriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsJobsTimeseriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsJobsTimeseriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/jobs/timeseries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.bucket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket", r.bucket, "form", "")
	}
	if r.granularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "form", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_id", r.teamId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AnalyticsAPIAnalyticsOverviewGetRequest struct {
	ctx        context.Context
	ApiService AnalyticsAPI
	range_     *string
	start      *string
	end        *string
	teamId     *string
}

// Time range preset
func (r AnalyticsAPIAnalyticsOverviewGetRequest) Range_(range_ string) AnalyticsAPIAnalyticsOverviewGetRequest {
	r.range_ = &range_
	return r
}

// Start date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsOverviewGetRequest) Start(start string) AnalyticsAPIAnalyticsOverviewGetRequest {
	r.start = &start
	return r
}

// End date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsOverviewGetRequest) End(end string) AnalyticsAPIAnalyticsOverviewGetRequest {
	r.end = &end
	return r
}

// Filter by team ID
func (r AnalyticsAPIAnalyticsOverviewGetRequest) TeamId(teamId string) AnalyticsAPIAnalyticsOverviewGetRequest {
	r.teamId = &teamId
	return r
}

func (r AnalyticsAPIAnalyticsOverviewGetRequest) Execute() (*AnalyticsOverviewResponse, *http.Response, error) {
	return r.ApiService.AnalyticsOverviewGetExecute(r)
}

/*
AnalyticsOverviewGet Get analytics overview

Returns high-level analytics insights including job statistics, page outcomes, credit usage, and webhook metrics for the specified time range

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AnalyticsAPIAnalyticsOverviewGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsOverviewGet(ctx context.Context) AnalyticsAPIAnalyticsOverviewGetRequest {
	return AnalyticsAPIAnalyticsOverviewGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnalyticsOverviewResponse
func (a *AnalyticsAPIService) AnalyticsOverviewGetExecute(r AnalyticsAPIAnalyticsOverviewGetRequest) (*AnalyticsOverviewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsOverviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsOverviewGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_id", r.teamId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AnalyticsAPIAnalyticsPagesTimeseriesGetRequest struct {
	ctx         context.Context
	ApiService  AnalyticsAPI
	range_      *string
	start       *string
	end         *string
	bucket      *string
	granularity *string
	teamId      *string
}

// Time range preset
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) Range_(range_ string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.range_ = &range_
	return r
}

// Start date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) Start(start string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.start = &start
	return r
}

// End date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) End(end string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.end = &end
	return r
}

// Time bucket granularity
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) Bucket(bucket string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.bucket = &bucket
	return r
}

// Alias for bucket parameter
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) Granularity(granularity string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.granularity = &granularity
	return r
}

// Filter by team ID
func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) TeamId(teamId string) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	r.teamId = &teamId
	return r
}

func (r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) Execute() (*AnalyticsPagesTimeseriesGet200Response, *http.Response, error) {
	return r.ApiService.AnalyticsPagesTimeseriesGetExecute(r)
}

/*
AnalyticsPagesTimeseriesGet Get page analytics timeseries

Returns page outcomes aggregated by time buckets including totals, completion, failure, and token counts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AnalyticsAPIAnalyticsPagesTimeseriesGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsPagesTimeseriesGet(ctx context.Context) AnalyticsAPIAnalyticsPagesTimeseriesGetRequest {
	return AnalyticsAPIAnalyticsPagesTimeseriesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnalyticsPagesTimeseriesGet200Response
func (a *AnalyticsAPIService) AnalyticsPagesTimeseriesGetExecute(r AnalyticsAPIAnalyticsPagesTimeseriesGetRequest) (*AnalyticsPagesTimeseriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsPagesTimeseriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsPagesTimeseriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/pages/timeseries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.bucket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket", r.bucket, "form", "")
	}
	if r.granularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "granularity", r.granularity, "form", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_id", r.teamId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AnalyticsAPIAnalyticsTemplatesTopGetRequest struct {
	ctx        context.Context
	ApiService AnalyticsAPI
	range_     *string
	start      *string
	end        *string
	limit      *int32
	teamId     *string
}

// Time range preset
func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) Range_(range_ string) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	r.range_ = &range_
	return r
}

// Start date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) Start(start string) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	r.start = &start
	return r
}

// End date (RFC3339 or YYYY-MM-DD format)
func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) End(end string) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	r.end = &end
	return r
}

// Maximum number of templates to return (default: 10, max: 100)
func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) Limit(limit int32) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	r.limit = &limit
	return r
}

// Filter by team ID
func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) TeamId(teamId string) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	r.teamId = &teamId
	return r
}

func (r AnalyticsAPIAnalyticsTemplatesTopGetRequest) Execute() (*AnalyticsTopTemplatesResponse, *http.Response, error) {
	return r.ApiService.AnalyticsTemplatesTopGetExecute(r)
}

/*
AnalyticsTemplatesTopGet Get top templates analytics

Returns the most frequently used templates ranked by job count, usage count, and credits consumed

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AnalyticsAPIAnalyticsTemplatesTopGetRequest
*/
func (a *AnalyticsAPIService) AnalyticsTemplatesTopGet(ctx context.Context) AnalyticsAPIAnalyticsTemplatesTopGetRequest {
	return AnalyticsAPIAnalyticsTemplatesTopGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnalyticsTopTemplatesResponse
func (a *AnalyticsAPIService) AnalyticsTemplatesTopGetExecute(r AnalyticsAPIAnalyticsTemplatesTopGetRequest) (*AnalyticsTopTemplatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AnalyticsTopTemplatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AnalyticsTemplatesTopGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/templates/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_id", r.teamId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
